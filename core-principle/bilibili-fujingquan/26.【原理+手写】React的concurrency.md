# React的concurrency

React将流程分为了两个阶段：

-render: 负责将需要渲染的组件【首次渲染就是App组件，更新阶段就是哪个组件需要更新就是哪个组件】内部辑以及react的内部逻辑进行执行，并最终得出衣服fiber清单【记录了最终要展示给用户看的真实dom树是什么样的，要增加哪些dom，要单纯更新的dom】
-commit: 负责将fiber清单转换为真实dom就ok了【非常非常非常简单而且常规的工作，压根没有什么逻辑】所有commit阶段的工作 百分之九十九点九的项目里可以在一帧【16ms】内执行完的

我们需要对render阶段做一点小手脚

- requestAnimationFrame: 一帧内必定要执行的函数

  ```js
  requestAnimationFrame(cb); // 这个cb会在浏览器的每一帧重排前都会执行
  ```

- requestIdleCallback
  
  ```js
  requestIdleCallback(cb); // 这个cb会在每一帧还有多余时间的时候执行
  ```

我们探究一下render阶段的时候用户会看到什么？？

首次渲染：

- render阶段用户看到的是什么？ 白屏 2s之内是不是都能接受 3s 用户可不可以和页面交互？ 【分情况】
  - 整个页面都是由react写的，而且只有一个根组件，这种情况用户是没法和页面交互的，正常
  - 整个页面只有一部分是由react接管和管理的，或者说整个页面有多个根组件【多个react容器】，这种情况用户是可以和页面交互的，因为不被react所管理的地方可能已经渲染出来了，正常的

更新时：

- render阶段用户看到的是什么？ 是不是更新前那个画面，这个时候用户可不可以和页面交互？ 是可以的

用户都没法和页面交互 他怎么造成掉帧啊？ 可以造成掉帧【但是由于界面本来就是白屏 用户压根感知不到掉帧】

下面说的情况只发生在render阶段的执行时长超过16ms的情况

如果是第二种情况就意味着 当前被react接管的这一块地方还在工作【js引擎还在工作】，但是用户可以直接和该区域以外的其他dom进行交互 必然会造成掉帧 那么用户的输入事件就丢失了 【这就是我们要处理的】

更新时用户已经可以看到之前的画面了，那就意味着可以交互，可以交互 这时候你的render还在工作中，但是用户已经开始交互了，那是不是又必然掉帧

那现在我们来走一条思路: **，既然说用户的输入没法被响应式因为掉帧导致的，那掉帧又是因为某一帧的执行时间太过长导致的，而在react里，掉帧的情况无非就是因为render阶段的逻辑太多导致的**

react是不是一个一个的react元素拼成的？ App 每写的一个东西都是一个组件 react元素 通过React.createElement创建的就是react元素

这些成千上万个react元素组合在一起就成为了庞大的render阶段要做的事情 那我们就把他们拆开

乐高 小积木 堆成一个大房子 我这个大房子进门可能进不来 那我把他拆了拆成一个一个的乐高的小零件 是不是就可以过去了

通过creatElement返回的就已经是一个react元素了对不对，就算你是一个组件 是不是也会被编译成createElement, 只不过你的type值不一样 console.log(App)

根组件是App { type: App function, children: [] }